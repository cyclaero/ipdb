//  geoip.c
//  geoip
//
//  Created by Dr. Rolf Jansen on 2016-07-17.
//  Copyright © 2016 projectworld.net. All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//
//  1. Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//  2. Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
//  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
//  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
//  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
//  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <errno.h>
#include <math.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/time.h>

#include "store.h"


void usage(const char *executable)
{
   const char *r = executable + strvlen(executable);
   while (--r >= executable && *r != '/'); r++;
   printf("%s v1.0.1 ("SVNREV"), Copyright © 2016 Dr. Rolf Jansen\n\n", r);
   printf("Usage:\n\n");
   printf("1) look-up the country code belonging to an IPv4 address given by the last command line argument:\n\n");
   printf("   %s [-r bstfile] [-h] <dotted IPv4 address>\n", r);
   printf("      <IPv4 address>    a dotted IPv4 address to be looked-up.\n\n");
   printf("2) generate a sorted list of IPv4 address/masklen pairs per country code, formatted as ipfw table construction directives:\n\n");
   printf("   %s -t [CC:DD:EE:..] [-n table number] [-v table value] [-r bstfile] [-h]\n\n", r);
   printf("      -t [CC:DD:EE:..]  output all IPv4 address/masklen pairs belonging to the listed countries, given by 2 letter\n");
   printf("                        capital country codes, separated by colon. An empty CC list means any country code.\n");
   printf("      -n table number   the ipfw table number between 0 and 65534 [default: 0].\n");
   printf("      -v table value    the 32-bit unsigned value of the ipfw table entry [default: 0].\n");
   printf("      -p                plain IP table generation, i.e. without ipfw construction directives, -n and -v flags are ignored.\n\n");
   printf("valid arguments in both usage forms:\n\n");
   printf("      -r bstfile        the path to the binary file with the consolidated IP ranges that has been.\n");
   printf("                        generated by the 'ipdb' tool [default: /usr/local/etc/ipdb/IPRanges/ipcc.bst].\n");
   printf("      -h                show these usage instructions.\n\n");
}


CCNode **CCTable = NULL;
IPNode  *IPStore = NULL;


static inline int intlb(double x)
{
   double lb = log2(x);
   ((uint8_t *)&lb)[b64_0] |= 1;  // bump up the least significant bit, so floor() is guaranteed to do the expected thing
   return (int)floor(lb);
}

static inline int inteb(int e)
{
   static int eb[32] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576,
                         2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648 };
   return (0 <= e && e <= 31) ? eb[e] : 1;
}

int main(int argc, char *argv[])
{
   bool plainFlag = false;
   int32_t  ch,
            rc    = 0,
            tnum  = 0;
   uint32_t tval  = 0;
   char *ccList   = NULL,
        *bstfname = "/usr/local/etc/ipdb/IPRanges/ipcc.bst";
   char *cmd      = argv[0];

   while ((ch = getopt(argc, argv, "t:n:pv:r:h")) != -1)
   {
      switch (ch)
      {
         case 't':
            ccList = optarg;
            break;

         case 'n':
            tnum = (int32_t)strtol(optarg, NULL, 10);
            if (tnum < 0 || 65534 < tnum || tnum == 0 && errno == EINVAL)
               goto arg_err;
            break;

         case 'p':
            plainFlag = true;
            break;

         case 'v':
            tval = (uint32_t)strtol(optarg, NULL, 10);
            if (tval == 0 && errno == EINVAL)
               goto arg_err;
            break;

         case 'r':
            bstfname = optarg;
            break;

         arg_err:
            printf("Incorrect argument:\n -%c %s, ...\n\n", ch, optarg);
         default:
            rc = 1;
         case 'h':
            usage(cmd);
            return rc;
      }
   }

   argc -= optind;
   argv += optind;

   if (argc != 1 && !ccList)
   {
      printf("Wrong number of arguments:\n %s, ...\n\n", argv[0]);
      usage(cmd);
      return 1;
   }


   struct stat st;
   FILE *in;
   if (stat(bstfname, &st) == noerr && st.st_size && (in = fopen(bstfname, "r")))
   {
      IPv4Desc ipdsc, ipdsc_lo, ipdsc_hi;
      IPSet *sortedIPSets = allocate(st.st_size, false);
      if (fread(sortedIPSets, st.st_size, 1, in))
      {
         if (ccList == NULL)           // first usage form -- lookup country code for a given IPv4 address
         {
            IPStore = sortedIPSetsToTree(sortedIPSets, 0, (int)(st.st_size/sizeof(uint32_t))/3 - 1);
            sscanf(argv[0], "%hhu.%hhu.%hhu.%hhu", &ipdsc.nibble[b32_3], &ipdsc.nibble[b32_2], &ipdsc.nibble[b32_1], &ipdsc.nibble[b32_0]);

            IPNode *node = findIPNode(ipdsc.number, IPStore);
            if (node)
            {
               ipdsc_lo.number = node->lo;
               ipdsc_hi.number = node->hi;
               printf("%s in %d.%d.%d.%d-%d.%d.%d.%d in %s\n\n", argv[0],
                                                                 ipdsc_lo.nibble[b32_3], ipdsc_lo.nibble[b32_2], ipdsc_lo.nibble[b32_1], ipdsc_lo.nibble[b32_0],
                                                                 ipdsc_hi.nibble[b32_3], ipdsc_hi.nibble[b32_2], ipdsc_hi.nibble[b32_1], ipdsc_hi.nibble[b32_0],
                                                                 (char *)&node->cc);
            }
            else
               printf("%s not found\n\n", argv[0]);

            releaseIPTree(IPStore);
         }

         else // (ccList != NULL)      // second usage form -- generate ipfw table construction directives
         {
            CCTable = createCCTable();

            int count = 0;
            char *cc = ccList;
            while (*cc)
            {
               int tl = taglen(cc);
               if (cc[tl] == ':')
                  cc[tl++] = '\0';
               storeCC(CCTable, *(uint16_t *)uppercase(cc, 2));
               cc += tl;
            }

            int i, k, m, n = (int)(st.st_size/sizeof(uint32_t))/3;
            for (i = 0; i < n; i++)
            {
               if (!*ccList || findCC(CCTable, sortedIPSets[i][2]))
               {
                  ipdsc_lo.number = sortedIPSets[i][0];
                  do
                  {
                     m = intlb(sortedIPSets[i][1] - ipdsc_lo.number + 1);
                     while (ipdsc_lo.number % (k = inteb(m)))
                        m--;

                     if (plainFlag)
                        printf("%d.%d.%d.%d/%d\n", ipdsc_lo.nibble[b32_3], ipdsc_lo.nibble[b32_2], ipdsc_lo.nibble[b32_1], ipdsc_lo.nibble[b32_0], 32 - m);
                     else if (tval != 0)
                        printf("table %d add %d.%d.%d.%d/%d %u\n", tnum, ipdsc_lo.nibble[b32_3], ipdsc_lo.nibble[b32_2], ipdsc_lo.nibble[b32_1], ipdsc_lo.nibble[b32_0], 32 - m, tval);
                     else
                        printf("table %d add %d.%d.%d.%d/%d\n", tnum, ipdsc_lo.nibble[b32_3], ipdsc_lo.nibble[b32_2], ipdsc_lo.nibble[b32_1], ipdsc_lo.nibble[b32_0], 32 - m);

                     count++;
                  }
                  while ((ipdsc_lo.number += k) < sortedIPSets[i][1]);
               }
            }

            if (!count)
               printf("\n");

            releaseCCTable(CCTable);
         }
      }

      deallocate(VPR(sortedIPSets), false);
      fclose(in);

      return 0;
   }

   return 1;
}
